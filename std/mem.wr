// Wraith Standard Library
// Memory manipulation functions optimized for 6502

/// Copy memory from source to destination
/// - dest: Destination pointer address
/// - src: Source pointer address
/// - len: Number of bytes to copy
///
/// Note: Uses indexed addressing with dest/src as base addresses
pub fn memcpy(dest: u16, src: u16, len: u8) {
    // For simplicity in this demo, we use inline assembly
    asm {
        "LDY #$00",
        "loop_memcpy:",
        "LDA {src},Y",
        "STA {dest},Y",
        "INY",
        "CPY {len}",
        "BNE loop_memcpy",
    }
}

/// Fill memory with a constant byte value
/// - dest: Destination address
/// - value: Byte value to fill with
/// - len: Number of bytes to fill
pub fn memset(dest: u16, value: u8, len: u8) {
    asm {
        "LDA {value}",
        "LDY #$00",
        "loop_memset:",
        "STA {dest},Y",
        "INY",
        "CPY {len}",
        "BNE loop_memset",
    }
}

/// Compare two memory regions for equality
/// - a: First memory region address
/// - b: Second memory region address
/// - len: Number of bytes to compare
/// Returns: 1 if equal, 0 if not equal (as u8 for simplicity)
pub fn memcmp(a: u16, b: u16, len: u8) -> u8 {
    let i: u8 = 0;
    loop {
        if i >= len { break; }

        let byte_a: u8 = 0;
        let byte_b: u8 = 0;
        asm {
            "LDY {i}",
            "LDA {a},Y",
            "STA {byte_a}",
            "LDA {b},Y",
            "STA {byte_b}"
        }

        if byte_a != byte_b {
            return 0;
        }

        i = i + 1;
    }
    return 1;
}

// ============================================================================
// Indirect Memory Access
// ============================================================================

/// Read a byte from an address using indirect addressing
///
/// Equivalent to: byte = *(address) in C
/// Uses 6502 indirect indexed addressing mode
///
/// Example:
/// ```
/// value: u8 = mem_read(0x0400);  // Read from $0400
/// ```
pub fn mem_read(address: u16) -> u8 {
    asm {
        "LDY #$00",
        "LDA ({address}),Y"
    }
    // Result is in A register, will be returned
}

/// Write a byte to an address using indirect addressing
///
/// Equivalent to: *(address) = value in C
/// Uses 6502 indirect indexed addressing mode
///
/// Example:
/// ```
/// mem_write(0x0400, 42);  // Write 42 to $0400
/// ```
pub fn mem_write(address: u16, value: u8) {
    asm {
        "LDY #$00",
        "LDA {value}",
        "STA ({address}),Y"
    }
}

/// Jump to address (indirect)
///
/// Transfers execution to the address specified.
/// WARNING: This is typically used for monitor/debugger "Go" commands.
/// Execution may not return unless the target code explicitly returns.
///
/// Example:
/// ```
/// mem_jump(0x8000);  // Execute code at $8000
/// ```
pub fn mem_jump(address: u16) {
    asm {
        "JMP ({address})"
    }
}

// ============================================================================
// String Operations
// ============================================================================

/// Copy string contents to a buffer with overflow protection
/// - dest: Destination buffer address
/// - dest_size: Size of destination buffer
/// - s: Source string
/// Returns: Number of bytes actually copied (may be less than s.len if buffer too small)
pub fn str_copy(dest: u16, dest_size: u16, s: str) -> u16 {
    // Determine how many bytes to copy (min of string length and buffer size)
    let copy_len: u16 = s.len;
    if copy_len > dest_size {
        copy_len = dest_size;
    }

    if copy_len == 0 as u16 {
        return 0 as u16;
    }

    // Fast path: use Y-indexed addressing for strings <= 255 bytes
    if copy_len <= 255 as u16 {
        let len8: u8 = copy_len as u8;
        let i: u8 = 0;
        loop {
            if i >= len8 { break; }

            let ch: u8 = s[i];
            asm {
                "LDY {i}",
                "LDA {ch}",
                "STA {dest},Y"
            }
            i = i + 1;
        }
    } else {
        // Slow path: use mem_read/mem_write for strings > 255 bytes
        let src_lo: u8 = 0;
        let src_hi: u8 = 0;

        asm {
            "LDA {s}",
            "CLC",
            "ADC #$02",
            "STA {src_lo}",
            "LDA {s}+1",
            "ADC #$00",
            "STA {src_hi}"
        }

        let src: u16 = ((src_hi as u16) << 8) | (src_lo as u16);

        let i: u16 = 0 as u16;
        loop {
            if i >= copy_len { break; }

            let ch: u8 = mem_read(src + i);
            mem_write(dest + i, ch);

            i = i + 1 as u16;
        }
    }

    return copy_len;
}
