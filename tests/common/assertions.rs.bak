//! Custom assertions for testing assembly output and compiler behavior

/// Assert that assembly contains specific pattern
pub fn assert_asm_contains(asm: &str, pattern: &str) {
    assert!(
        asm.contains(pattern),
        "Expected assembly to contain '{}' but it didn't.\nAssembly:\n{}",
        pattern,
        asm
    );
}

/// Assert that assembly does NOT contain specific pattern
#[allow(dead_code)]
pub fn assert_asm_not_contains(asm: &str, pattern: &str) {
    assert!(
        !asm.contains(pattern),
        "Expected assembly to NOT contain '{}' but it did.\nAssembly:\n{}",
        pattern,
        asm
    );
}

/// Assert that first pattern appears before second in assembly
pub fn assert_asm_order(asm: &str, first: &str, second: &str) {
    let first_pos = asm
        .find(first)
        .unwrap_or_else(|| panic!("Could not find '{}' in assembly", first));
    let second_pos = asm
        .find(second)
        .unwrap_or_else(|| panic!("Could not find '{}' in assembly", second));

    assert!(
        first_pos < second_pos,
        "Expected '{}' to appear before '{}' but it didn't.\nAssembly:\n{}",
        first,
        second,
        asm
    );
}

/// Assert that a pattern appears exactly N times
#[allow(dead_code)]
pub fn assert_asm_count(asm: &str, pattern: &str, expected: usize) {
    let actual = asm.matches(pattern).count();
    assert_eq!(
        actual, expected,
        "Expected '{}' to appear {} times but it appeared {} times.\nAssembly:\n{}",
        pattern, expected, actual, asm
    );
}

/// Assert that assembly matches a regex pattern
/// Note: Requires regex crate as dev dependency
#[allow(dead_code)]
#[cfg(feature = "regex")]
pub fn assert_asm_matches_regex(asm: &str, pattern: &str) {
    let re = regex::Regex::new(pattern).expect("Invalid regex pattern");
    assert!(
        re.is_match(asm),
        "Expected assembly to match regex '{}' but it didn't.\nAssembly:\n{}",
        pattern,
        asm
    );
}

/// Assert that an optimization was applied (pattern removed)
#[allow(dead_code)]
pub fn assert_optimization_applied(asm: &str, inefficient_pattern: &str) {
    assert_asm_not_contains(asm, inefficient_pattern);
}

/// Assert that specific instructions appear in sequence
#[allow(dead_code)]
pub fn assert_instruction_sequence(asm: &str, instructions: &[&str]) {
    let asm_lines: Vec<&str> = asm.lines().map(|l| l.trim()).collect();

    let mut search_start = 0;
    for inst in instructions {
        let found = asm_lines[search_start..]
            .iter()
            .position(|line| line.contains(inst))
            .map(|pos| search_start + pos);

        match found {
            Some(pos) => search_start = pos + 1,
            None => panic!(
                "Could not find instruction '{}' after previous instruction in sequence.\nAssembly:\n{}",
                inst, asm
            ),
        }
    }
}

/// Helper to check if first appears before second (returns bool instead of panicking)
#[allow(dead_code)]
pub fn appears_before(asm: &str, first: &str, second: &str) -> bool {
    if let (Some(first_pos), Some(second_pos)) = (asm.find(first), asm.find(second)) {
        first_pos < second_pos
    } else {
        false
    }
}
