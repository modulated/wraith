// TL16C550B UART Demo for 65C02
// This demonstrates initialization and basic I/O with a 16550 UART

// UART Register addresses (adjust base address for your hardware)
// Assuming UART is mapped at $9000
addr UART_BASE = 0x9000;

// Register offsets from base
addr UART_RBR = UART_BASE + 0;  // Receiver Buffer (read, DLAB=0)
addr UART_THR = UART_BASE + 0;  // Transmitter Holding (write, DLAB=0)
addr UART_DLL = UART_BASE + 0;  // Divisor Latch Low (DLAB=1)
addr UART_DLM = UART_BASE + 1;  // Divisor Latch High (DLAB=1)
addr UART_IER = UART_BASE + 1;  // Interrupt Enable (DLAB=0)
addr UART_IIR = UART_BASE + 2;  // Interrupt ID (read)
addr UART_FCR = UART_BASE + 2;  // FIFO Control (write)
addr UART_LCR = UART_BASE + 3;  // Line Control
addr UART_MCR = UART_BASE + 4;  // Modem Control
addr UART_LSR = UART_BASE + 5;  // Line Status
addr UART_MSR = UART_BASE + 6;  // Modem Status
addr UART_SCR = UART_BASE + 7;  // Scratch

// LCR register bits
addr LCR_DLAB = 0x80;    // Divisor Latch Access Bit
addr LCR_8N1  = 0x03;    // 8 data bits, no parity, 1 stop bit

// FCR register bits
addr FCR_ENABLE  = 0x01; // Enable FIFOs
addr FCR_RX_RST  = 0x02; // Reset RX FIFO
addr FCR_TX_RST  = 0x04; // Reset TX FIFO
addr FCR_TRIGGER = 0xC0; // 14-byte trigger level

// LSR register bits
addr LSR_DATA_RDY = 0x01; // Data ready
addr LSR_THR_EMPTY = 0x20; // Transmitter holding register empty

// MCR register bits
addr MCR_DTR = 0x01;      // Data Terminal Ready
addr MCR_RTS = 0x02;      // Request to Send

// Baud rate divisors for 1.8432 MHz crystal
// Divisor = 1843200 / (16 * baud_rate)
addr BAUD_9600   = 12;    // 9600 baud
addr BAUD_19200  = 6;     // 19200 baud
addr BAUD_38400  = 3;     // 38400 baud
addr BAUD_115200 = 1;     // 115200 baud

/// Initialize the UART to 9600 baud, 8N1
fn uart_init() {
    // Set DLAB=1 to access divisor latches
    UART_LCR = LCR_DLAB;

    // Set baud rate to 9600
    UART_DLL = BAUD_9600;
    UART_DLM = 0;

    // Set DLAB=0 and configure 8N1 format
    UART_LCR = LCR_8N1;

    // Enable and reset FIFOs
    UART_FCR = FCR_ENABLE | FCR_RX_RST | FCR_TX_RST | FCR_TRIGGER;

    // Set DTR and RTS
    UART_MCR = MCR_DTR | MCR_RTS;

    // Disable all interrupts (polling mode)
    UART_IER = 0;
}

/// Wait for transmitter to be ready
fn uart_wait_tx() {
    status: u8 = 0;

    // Poll LSR until THR is empty
    while (status & LSR_THR_EMPTY) == 0 {
        status = UART_LSR;
    }
}

/// Send a single character
fn uart_putc(ch: u8) {
    uart_wait_tx();
    UART_THR = ch;
}

/// Check if data is available to read
fn uart_data_ready() -> u8 {
    status: u8 = UART_LSR;
    return status & LSR_DATA_RDY;
}

/// Receive a single character (blocking)
fn uart_getc() -> u8 {
    // Wait for data to be ready
    while uart_data_ready() == 0 {
        // Spin
    }

    return UART_RBR;
}

/// Send a message to UART (simplified version)
fn uart_puts_simple(msg: u8) {
    // For demo purposes - just send a marker character
    uart_putc(msg);
}

/// Send a newline (CR+LF)
fn uart_newline() {
    uart_putc(13);  // CR
    uart_putc(10);  // LF
}

/// Print a byte as two hex digits
fn uart_print_hex(value: u8) {
    high: u8 = value >> 4;
    low: u8 = value & 0x0F;

    // Print high nibble
    if high < 10 {
        uart_putc(48 + high);  // '0' + digit
    } else {
        uart_putc(55 + high);  // 'A' + (digit - 10)
    }

    // Print low nibble
    if low < 10 {
        uart_putc(48 + low);
    } else {
        uart_putc(55 + low);
    }
}

/// Simple echo demo - echoes back received characters
fn uart_echo_demo() {
    received: u8 = 0;

    // Send welcome message marker
    uart_putc(72);  // 'H'
    uart_putc(101); // 'e'
    uart_putc(108); // 'l'
    uart_putc(108); // 'l'
    uart_putc(111); // 'o'
    uart_newline();

    // Echo loop
    while 1 == 1 {
        received = uart_getc();

        // Echo the character
        uart_putc(received);

        // If Enter was pressed, send newline
        if received == 13 {
            uart_newline();
        }

        // Break on ESC key (0x1B)
        if received == 27 {
            break;
        }
    }
}

/// Main entry point
#[org(0x8000)]
fn main() {
    // Initialize UART
    uart_init();

    // Send initialization marker 'I'
    uart_putc(73);
    uart_putc(78);  // 'N'
    uart_putc(73);  // 'I'
    uart_putc(84);  // 'T'
    uart_newline();

    // Run echo demo
    uart_echo_demo();

    // Send done marker 'D'
    uart_putc(68);
    uart_putc(79);  // 'O'
    uart_putc(78);  // 'N'
    uart_putc(69);  // 'E'
    uart_newline();
}
