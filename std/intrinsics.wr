// Wraith Intrinsics - Low-level CPU control functions
// These functions map directly to 6502 instructions for processor control

// ============================================================================
// Interrupt Control
// ============================================================================

/// Enable interrupts by clearing the interrupt disable flag
/// Maps to: CLI (Clear Interrupt Disable)
/// Cycles: 2
///
/// After calling this function, the CPU will respond to IRQ interrupts.
/// Note: NMI interrupts are always enabled and cannot be disabled.
#[inline]
fn enable_interrupts() {
    asm {
        "CLI",
    }
}

/// Disable interrupts by setting the interrupt disable flag
/// Maps to: SEI (Set Interrupt Disable)
/// Cycles: 2
///
/// After calling this function, the CPU will ignore IRQ interrupts.
/// Use this for critical sections that must not be interrupted.
/// Note: NMI interrupts cannot be disabled and will still occur.
#[inline]
fn disable_interrupts() {
    asm {
        "SEI",
    }
}

// ============================================================================
// Carry Flag Control
// ============================================================================

/// Clear the carry flag
/// Maps to: CLC (Clear Carry)
/// Cycles: 2
///
/// Used before addition operations to ensure no carry-in.
/// The compiler normally handles this automatically for additions.
#[inline]
fn clear_carry() {
    asm {
        "CLC",
    }
}

/// Set the carry flag
/// Maps to: SEC (Set Carry)
/// Cycles: 2
///
/// Used before subtraction operations to ensure no borrow.
/// The compiler normally handles this automatically for subtractions.
/// Can also be used for manual multi-byte arithmetic.
#[inline]
fn set_carry() {
    asm {
        "SEC",
    }
}

// ============================================================================
// Decimal Mode Control
// ============================================================================

/// Clear decimal mode - use binary arithmetic
/// Maps to: CLD (Clear Decimal Mode)
/// Cycles: 2
///
/// Switches the CPU to binary arithmetic mode (the default).
/// In binary mode, ADC and SBC perform normal binary addition/subtraction.
/// Most programs should run in binary mode.
#[inline]
fn clear_decimal() {
    asm {
        "CLD",
    }
}

/// Set decimal mode - use BCD arithmetic
/// Maps to: SED (Set Decimal Mode)
/// Cycles: 2
///
/// Switches the CPU to Binary-Coded Decimal (BCD) mode.
/// In BCD mode, ADC and SBC treat values as packed BCD digits (0-9).
/// Useful for calculations that need to display decimal results.
/// Example: 0x09 + 0x01 = 0x10 (not 0x0A)
#[inline]
fn set_decimal() {
    asm {
        "SED",
    }
}

// ============================================================================
// Other CPU Control
// ============================================================================

/// Clear the overflow flag
/// Maps to: CLV (Clear Overflow)
/// Cycles: 2
///
/// Clears the overflow (V) flag in the processor status register.
/// The overflow flag is set by ADC/SBC for signed arithmetic overflow.
#[inline]
fn clear_overflow() {
    asm {
        "CLV",
    }
}

/// No operation - waste CPU cycles
/// Maps to: NOP (No Operation)
/// Cycles: 2
///
/// Does nothing for 2 CPU cycles. Useful for:
/// - Timing delays
/// - Code alignment
/// - Placeholder for future instructions
#[inline]
fn nop() {
    asm {
        "NOP",
    }
}

/// Software interrupt / breakpoint
/// Maps to: BRK (Break)
/// Cycles: 7
///
/// Triggers a software interrupt:
/// 1. Pushes PC+2 to stack
/// 2. Pushes status flags to stack (with B flag set)
/// 3. Sets interrupt disable flag
/// 4. Jumps to IRQ/BRK vector at $FFFE
///
/// Used for debugging or implementing system calls.
/// Note: Most debuggers/emulators treat BRK as a breakpoint.
#[inline]
fn brk() {
    asm {
        "BRK",
    }
}

// ============================================================================
// Stack Pointer Control
// ============================================================================

/// Set the stack pointer to a specific value
/// Maps to: LDX #value; TXS
/// Cycles: 4 (2 for LDX, 2 for TXS)
///
/// Sets the stack pointer to the given value.
/// The 6502 stack lives in page 1 ($0100-$01FF).
/// Common usage: set_stack_pointer(0xFF) to initialize SP to top of stack ($01FF)
///
/// Example:
/// ```
/// set_stack_pointer(0xFF);  // Stack pointer now at $01FF (top of stack)
/// ```

#[inline]
fn set_stack_pointer(value: u8) {
    asm {
        "LDX {value}",
        "TXS",
    }
}

// ============================================================================
// String Utilities
// ============================================================================
//
// String Type: str
//   - Type-safe string primitive
//   - Stored as 2-byte pointer to length-prefixed data in DATA section
//   - Format in memory: [u16 length LE][bytes...]
//   - Immutable, static lifetime
//
// Operations:
//   s.len    -> u16 (string length in bytes)
//   s[i]     -> u8  (byte at index i, no bounds check - programmer's responsibility)
//
// Common Patterns:

/// Iterate through all characters
/// Example:
/// ```
/// fn print_string(s: str) {
///     i: u16 = 0;
///     loop {
///         if i >= s.len { break; }
///         uart_putc(s[i as u8]);
///         i = i + 1;
///     }
/// }
/// ```

/// Compare two strings
/// Example:
/// ```
/// fn str_eq(a: str, b: str) -> bool {
///     if a.len != b.len { return false; }
///     i: u16 = 0;
///     loop {
///         if i >= a.len { break; }
///         if a[i as u8] != b[i as u8] { return false; }
///         i = i + 1;
///     }
///     return true;
/// }
/// ```

/// Find character in string
/// Returns index or 0xFFFF if not found
/// Example:
/// ```
/// fn find_char(s: str, ch: u8) -> u16 {
///     i: u16 = 0;
///     loop {
///         if i >= s.len { return 0xFFFF; }
///         if s[i as u8] == ch { return i; }
///         i = i + 1;
///     }
/// }
/// ```

// Note: When using a string literal like "Hello", the compiler:
//   1. Stores the string data in DATA section with length prefix
//   2. Returns a pointer (str type) to the data
