// Pointer Arithmetic Example
//
// Demonstrates using pointers for array manipulation and iteration
// This example shows how to:
// - Take addresses of array elements
// - Perform pointer arithmetic
// - Use pointers to iterate through arrays
// - Calculate memory offsets

const OUT: addr = 0x400;  // Output port

// Example 1: Basic pointer arithmetic
fn example_basic_pointer_arithmetic() {
    let arr: [u8; 5] = [10, 20, 30, 40, 50];

    // Get the base address of the array
    let base_addr: u16 = &arr[0] as u16;

    // Calculate addresses of other elements using pointer arithmetic
    let addr_0: u16 = base_addr;      // Address of arr[0]
    let addr_1: u16 = base_addr + 1;  // Address of arr[1]
    let addr_2: u16 = base_addr + 2;  // Address of arr[2]
    let addr_3: u16 = base_addr + 3;  // Address of arr[3]
    let addr_4: u16 = base_addr + 4;  // Address of arr[4]

    // Output the first element (direct access for demonstration)
    OUT = arr[0];
}

// Example 2: Iterating through an array using pointer arithmetic
fn example_iterate_array() {
    let buffer: [u8; 8] = [1, 2, 3, 4, 5, 6, 7, 8];

    // Get base address
    let base: u16 = &buffer[0] as u16;

    // Iterate using pointer arithmetic
    // In a real implementation, we'd use mem_read to read from computed addresses
    for i: u8 in 0..8 {
        // Calculate address: base + i
        let current_addr: u16 = base + (i as u16);

        // In practice, you would use mem_read(current_addr) here
        // For now, we just demonstrate the address calculation
    }
}

// Example 3: Calculating array element addresses
fn example_array_offsets() {
    let data: [u16; 4] = [100, 200, 300, 400];

    // Each u16 element is 2 bytes, so offsets are multiples of 2
    let base: u16 = &data[0] as u16;

    // Calculate addresses
    let addr0: u16 = base;          // Offset 0
    let addr1: u16 = base + 2;      // Offset 2 (u16 is 2 bytes)
    let addr2: u16 = base + 4;      // Offset 4
    let addr3: u16 = base + 6;      // Offset 6

    OUT = data[0] as u8;
}

// Example 4: Pointer difference (calculating distance between elements)
fn example_pointer_difference() {
    let array: [u8; 10] = [0; 10];

    // Get addresses of first and last elements
    let start: u16 = &array[0] as u16;
    let end: u16 = &array[9] as u16;

    // Calculate the number of bytes between them
    let distance: u16 = end - start;  // Should be 9 bytes

    // Distance represents the offset in bytes
    OUT = distance as u8;
}

// Example 5: Working with multidimensional arrays
fn example_2d_array_pointers() {
    // 3x3 matrix stored in row-major order
    let matrix: [[u8; 3]; 3] = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]
    ];

    // Get base address of the entire matrix
    let base: u16 = &matrix[0][0] as u16;

    // Calculate address of element at row 1, col 2
    // Formula: base + (row * num_cols + col)
    let row: u8 = 1;
    let col: u8 = 2;
    let num_cols: u8 = 3;

    let offset: u8 = row * num_cols + col;
    let element_addr: u16 = base + (offset as u16);

    // This points to matrix[1][2] which contains 6
    OUT = matrix[1][2];
}

// Example 6: Pointer bounds checking
fn example_pointer_bounds() {
    let buffer: [u8; 32] = [0; 32];

    let start_addr: u16 = &buffer[0] as u16;
    let end_addr: u16 = &buffer[31] as u16;

    // Calculate buffer size
    let size: u16 = (end_addr - start_addr) + 1;  // +1 to include last element

    // Check if an index is within bounds
    let index: u8 = 10;
    let addr: u16 = start_addr + (index as u16);

    // Verify bounds: addr must be >= start_addr and <= end_addr
    let in_bounds: bool = (addr >= start_addr) && (addr <= end_addr);

    if in_bounds {
        OUT = buffer[index];
    }
}

// Example 7: Copying array data using addresses
fn example_array_copy_addresses() {
    let source: [u8; 4] = [0xAA, 0xBB, 0xCC, 0xDD];
    let dest: [u8; 4] = [0; 4];

    // Get addresses of source and destination
    let src_addr: u16 = &source[0] as u16;
    let dst_addr: u16 = &dest[0] as u16;

    // In a real implementation, you'd use these addresses with mem_read/mem_write
    // or pass them to memcpy:
    // memcpy(dst_addr, src_addr, 4);

    OUT = source[0];
}

// Main entry point
#[reset]
fn main() {
    example_basic_pointer_arithmetic();
    example_iterate_array();
    example_array_offsets();
    example_pointer_difference();
    example_2d_array_pointers();
    example_pointer_bounds();
    example_array_copy_addresses();

    // Infinite loop
    loop {}
}
