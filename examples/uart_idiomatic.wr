// TL16C550B UART Example - Idiomatic Wraith
// Shows proper use of addr (for hardware) vs constants (for values)

// ============================================================================
// HARDWARE ADDRESSES (proper use of 'addr')
// ============================================================================

addr UART_BASE = 0x9000;

// UART registers - these are actual hardware addresses
addr UART_RBR = UART_BASE + 0;  // Receiver Buffer (read, DLAB=0)
addr UART_THR = UART_BASE + 0;  // Transmitter Holding (write, DLAB=0)
addr UART_DLL = UART_BASE + 0;  // Divisor Latch Low (DLAB=1)
addr UART_DLM = UART_BASE + 1;  // Divisor Latch High (DLAB=1)
addr UART_IER = UART_BASE + 1;  // Interrupt Enable (DLAB=0)
addr UART_FCR = UART_BASE + 2;  // FIFO Control (write)
addr UART_LCR = UART_BASE + 3;  // Line Control
addr UART_MCR = UART_BASE + 4;  // Modem Control
addr UART_LSR = UART_BASE + 5;  // Line Status

// ============================================================================
// CONFIGURATION CONSTANTS (using immutable statics)
// ============================================================================

// LCR register bit values
u8 LCR_DLAB = 0x80;    // Divisor Latch Access Bit
u8 LCR_8N1  = 0x03;    // 8 data bits, no parity, 1 stop bit

// FCR register bits
u8 FCR_ENABLE  = 0x01; // Enable FIFOs
u8 FCR_RX_RST  = 0x02; // Reset RX FIFO
u8 FCR_TX_RST  = 0x04; // Reset TX FIFO
u8 FCR_TRIGGER = 0xC0; // 14-byte trigger level

// LSR register bits
u8 LSR_DATA_RDY = 0x01; // Data ready
u8 LSR_THR_EMPTY = 0x20; // Transmitter holding register empty

// MCR register bits
u8 MCR_DTR = 0x01;      // Data Terminal Ready
u8 MCR_RTS = 0x02;      // Request to Send

// Baud rate divisors (for 1.8432 MHz crystal)
u8 BAUD_9600   = 12;
u8 BAUD_19200  = 6;
u8 BAUD_38400  = 3;
u8 BAUD_115200 = 1;

// ============================================================================
// UART FUNCTIONS
// ============================================================================

/// Initialize the UART to 9600 baud, 8N1
fn uart_init() {
    // Set DLAB=1 to access divisor latches
    UART_LCR = LCR_DLAB;

    // Set baud rate to 9600
    UART_DLL = BAUD_9600;
    UART_DLM = 0;

    // Set DLAB=0 and configure 8N1 format
    UART_LCR = LCR_8N1;

    // Enable and reset FIFOs
    UART_FCR = FCR_ENABLE | FCR_RX_RST | FCR_TX_RST | FCR_TRIGGER;

    // Set DTR and RTS
    UART_MCR = MCR_DTR | MCR_RTS;
}

/// Wait for transmitter to be ready
fn uart_wait_tx() {
    status: u8 = 0;

    // Poll LSR until THR is empty
    while (status & LSR_THR_EMPTY) == 0 {
        status = UART_LSR;
    }
}

/// Send a single character
fn uart_putc(ch: u8) {
    uart_wait_tx();
    UART_THR = ch;
}

/// Check if data is available to read
fn uart_data_ready() -> u8 {
    status: u8 = UART_LSR;
    return status & LSR_DATA_RDY;
}

/// Receive a single character (blocking)
fn uart_getc() -> u8 {
    // Wait for data to be ready
    while uart_data_ready() == 0 {
        // Spin wait
    }

    return UART_RBR;
}

#[org(0x8000)]
fn main() {
    // Initialize UART
    uart_init();

    // Send 'OK' message
    uart_putc(79);  // 'O'
    uart_putc(75);  // 'K'
    uart_putc(13);  // CR
    uart_putc(10);  // LF

    // Echo one character
    received: u8 = uart_getc();
    uart_putc(received);
}
