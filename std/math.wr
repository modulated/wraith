// Wraith Math Standard Library
// Mathematical operations optimized for u8 on 65C02
//
// This library provides efficient integer math operations for the 6502/65C02
// processor, focusing on unsigned 8-bit values. Where applicable, 65C02-specific
// instructions (SMB, RMB, BBS) are used for optimal performance.

// ============================================================================
// Comparison Operations
// ============================================================================

/// Return the minimum of two u8 values
/// Optimized assembly: Uses CMP and BCC to avoid boolean intermediate
/// Cycles: ~8 (1 comparison + 1 conditional branch)
#[inline]
fn min(a: u8, b: u8) -> u8 {
    asm {
        "LDA {a}",
        "CMP {b}",
        "BCC ISMIN",
        "LDA {b}",
        "ISMIN:",
    }
}

/// Return the maximum of two u8 values
/// Optimized assembly: Uses CMP and BCS to avoid boolean intermediate
/// Cycles: ~8 (1 comparison + 1 conditional branch)
#[inline]
fn max(a: u8, b: u8) -> u8 {
    asm {
        "LDA {a}",
        "CMP {b}",
        "BCS ISMAX",
        "LDA {b}",
        "ISMAX:",
    }
}

/// Clamp a value between min and max bounds (inclusive)
/// Optimized assembly: Two comparisons with early exit
/// Cycles: ~12-16 (best case: in range, worst case: clamped twice)
#[inline]
fn clamp(value: u8, min_val: u8, max_val: u8) -> u8 {
    asm {
        "LDA {value}",
        "CMP {min_val}",
        "BCS CHECK_MAX",
        "LDA {min_val}",
        "JMP DONE_CLAMP",
        "CHECK_MAX:",
        "CMP {max_val}",
        "BCC DONE_CLAMP",
        "BEQ DONE_CLAMP",
        "LDA {max_val}",
        "DONE_CLAMP:",
    }
}

// ============================================================================
// Bit Manipulation (65C02 SMB/RMB/BBS instructions)
// ============================================================================

/// Set a specific bit (0-7) in a byte using 65C02 SMB instructions
/// Cycles: ~18-20
/// Note: Uses zero page $20 for temporary storage
#[inline]
fn set_bit(value: u8, bit: u8) -> u8 {

    asm {
        "LDA {value}",
        "STA $20",

        "LDX {bit}",
        "CPX #$00",
        "BEQ bit0_s",
        "CPX #$01",
        "BEQ bit1_s",
        "CPX #$02",
        "BEQ bit2_s",
        "CPX #$03",
        "BEQ bit3_s",
        "CPX #$04",
        "BEQ bit4_s",
        "CPX #$05",
        "BEQ bit5_s",
        "CPX #$06",
        "BEQ bit6_s",
        "SMB7 $20",
        "JMP done_s",
        "bit0_s:",
        "SMB0 $20",
        "JMP done_s",
        "bit1_s:",
        "SMB1 $20",
        "JMP done_s",
        "bit2_s:",
        "SMB2 $20",
        "JMP done_s",
        "bit3_s:",
        "SMB3 $20",
        "JMP done_s",
        "bit4_s:",
        "SMB4 $20",
        "JMP done_s",
        "bit5_s:",
        "SMB5 $20",
        "JMP done_s",
        "bit6_s:",
        "SMB6 $20",
        "JMP done_s",
        "done_s:",
        "LDA $20",

    }

}

/// Clear a specific bit (0-7) in a byte using 65C02 RMB instructions
/// Cycles: ~18-20
/// Note: Uses zero page $20 for temporary storage
#[inline]
fn clear_bit(value: u8, bit: u8) -> u8 {

    asm {
        "LDA {value}",
        "STA $20",

        "LDX {bit}",
        "CPX #$00",
        "BEQ bit0_c",
        "CPX #$01",
        "BEQ bit1_c",
        "CPX #$02",
        "BEQ bit2_c",
        "CPX #$03",
        "BEQ bit3_c",
        "CPX #$04",
        "BEQ bit4_c",
        "CPX #$05",
        "BEQ bit5_c",
        "CPX #$06",
        "BEQ bit6_c",
        "RMB7 $20",
        "JMP done_c",
        "bit0_c:",
        "RMB0 $20",
        "JMP done_c",
        "bit1_c:",
        "RMB1 $20",
        "JMP done_c",
        "bit2_c:",
        "RMB2 $20",
        "JMP done_c",
        "bit3_c:",
        "RMB3 $20",
        "JMP done_c",
        "bit4_c:",
        "RMB4 $20",
        "JMP done_c",
        "bit5_c:",
        "RMB5 $20",
        "JMP done_c",
        "bit6_c:",
        "RMB6 $20",
        "JMP done_c",
        "done_c:",
        "LDA $20",

    }

}

/// Test if a specific bit (0-7) is set using 65C02 BBS instructions
/// Cycles: ~20-22
/// Returns: 1 if bit is set, 0 if clear
/// Note: Uses zero page $20 for temporary storage
#[inline]
fn test_bit(value: u8, bit: u8) -> u8 {

    asm {
        "LDA {value}",
        "STA $20",

        "LDX {bit}",
        "CPX #$00",
        "BEQ bit0_t",
        "CPX #$01",
        "BEQ bit1_t",
        "CPX #$02",
        "BEQ bit2_t",
        "CPX #$03",
        "BEQ bit3_t",
        "CPX #$04",
        "BEQ bit4_t",
        "CPX #$05",
        "BEQ bit5_t",
        "CPX #$06",
        "BEQ bit6_t",
        "BBS7 $20,bit_set_t",
        "JMP bit_clear_t",
        "bit0_t:",
        "BBS0 $20,bit_set_t",
        "JMP bit_clear_t",
        "bit1_t:",
        "BBS1 $20,bit_set_t",
        "JMP bit_clear_t",
        "bit2_t:",
        "BBS2 $20,bit_set_t",
        "JMP bit_clear_t",
        "bit3_t:",
        "BBS3 $20,bit_set_t",
        "JMP bit_clear_t",
        "bit4_t:",
        "BBS4 $20,bit_set_t",
        "JMP bit_clear_t",
        "bit5_t:",
        "BBS5 $20,bit_set_t",
        "JMP bit_clear_t",
        "bit6_t:",
        "BBS6 $20,bit_set_t",
        "JMP bit_clear_t",
        "bit_set_t:",
        "LDA #$01",
        "JMP done_t",
        "bit_clear_t:",
        "LDA #$00",
        "done_t:",

    }

}

// ============================================================================
// Saturating Arithmetic
// ============================================================================

/// Add two u8 values with saturation at 255
/// Optimized assembly: Result left in accumulator (no temp variable)
/// Cycles: ~6-8 (saved 2 cycles by eliminating STA)
/// Returns: a + b, or 255 if overflow would occur
#[inline]
fn saturating_add(a: u8, b: u8) -> u8 {
    asm {
        "CLC",
        "LDA {a}",
        "ADC {b}",
        "BCC no_overflow_add",
        "LDA #$FF",
        "no_overflow_add:",
    }
}

/// Subtract b from a with saturation at 0
/// Optimized assembly: Result left in accumulator (no temp variable)
/// Cycles: ~6-8 (saved 2 cycles by eliminating STA)
/// Returns: a - b, or 0 if underflow would occur
#[inline]
fn saturating_sub(a: u8, b: u8) -> u8 {
    asm {
        "SEC",
        "LDA {a}",
        "SBC {b}",
        "BCS no_underflow_sub",
        "LDA #$00",
        "no_underflow_sub:",
    }
}

// ============================================================================
// Advanced Bit Operations
// ============================================================================

/// Count the number of set bits (population count)
/// Optimized assembly: Uses Y register for counting, TYA at end
/// Cycles: ~58-76 (saved 2 cycles by using TYA instead of STY/LDA)
/// Returns: number of 1 bits in the value
#[inline]
fn count_bits(value: u8) -> u8 {
    asm {
        "LDA {value}",
        "LDX #$08",
        "LDY #$00",
        "count_loop:",
        "LSR A",
        "BCC bit_not_set",
        "INY",
        "bit_not_set:",
        "DEX",
        "BNE count_loop",
        "TYA",
    }
}

/// Reverse the bits in a byte
/// Optimized assembly: Uses zero page $20 for temp storage
/// Cycles: ~66-76 (saved cycles by using fixed ZP instead of variable)
/// Example: 0b11010010 -> 0b01001011
/// Note: Uses zero page $20 for temporary storage
#[inline]
fn reverse_bits(value: u8) -> u8 {
    asm {
        "LDA #$00",
        "STA $20",
        "LDA {value}",
        "LDX #$08",
        "reverse_loop:",
        "LSR A",
        "ROL $20",
        "DEX",
        "BNE reverse_loop",
        "LDA $20",
    }
}

/// Swap the high and low nibbles of a byte
/// Optimized assembly: Result left in accumulator
/// Cycles: ~10-14 (saved 2 cycles by eliminating STA)
/// Example: 0xAB -> 0xBA
#[inline]
fn swap_nibbles(value: u8) -> u8 {
    asm {
        "LDA {value}",
        "ASL A",
        "ADC #$80",
        "ROL A",
        "ADC #$80",
        "ROL A",
        "ADC #$80",
        "ROL A",
        "ADC #$80",
    }
}

// ============================================================================
// 16-bit Arithmetic Operations
// ============================================================================

/// Multiply two 16-bit unsigned integers
/// Algorithm: Shift-and-add method (optimized for 6502)
/// Cycles: ~800-1000 (depends on number of set bits in multiplier)
/// Returns: a * b (lower 16 bits if result overflows)
/// Note: Uses zero page $20-$27 for temporary storage
///
/// Memory map (parameters):
/// $80-$81: parameter a (multiplicand)
/// $82-$83: parameter b (multiplier)
///
/// Memory map (working):
/// $20-$21: multiplicand (shifted left each iteration)
/// $22-$23: result accumulator
/// $24-$25: multiplier (shifted right each iteration)
/// $26: loop counter (16 iterations)
pub fn mul16(a: u16, b: u16) -> u16 {
    asm {
        // Initialize result to 0
        "LDA #$00",
        "STA $22",
        "STA $23",

        // Load multiplicand from parameter a ($80-$81) into $20-$21
        "LDA $80",      // a.low
        "STA $20",
        "LDA $81",      // a.high
        "STA $21",

        // Load multiplier from parameter b ($82-$83) into $24-$25
        "LDA $82",      // b.low
        "STA $24",
        "LDA $83",      // b.high
        "STA $25",

        // Initialize loop counter to 16
        "LDX #$10",
        "STX $26",

        "mul16_loop:",
        // Check if LSB of multiplier is set
        "LDA $24",
        "LSR A",
        "BCC mul16_skip_add",

        // Add multiplicand to result
        "CLC",
        "LDA $22",
        "ADC $20",
        "STA $22",
        "LDA $23",
        "ADC $21",
        "STA $23",

        "mul16_skip_add:",
        // Shift multiplier right by 1
        "LSR $25",
        "ROR $24",

        // Shift multiplicand left by 1
        "ASL $20",
        "ROL $21",

        // Decrement counter and loop if not zero
        "DEC $26",
        "BNE mul16_loop",

        // Load result into A (low) and Y (high) per u16 return convention
        "LDA $22",
        "LDY $23",
    }
}

/// Divide two 16-bit unsigned integers
/// Algorithm: Non-restoring division (optimized for 6502)
/// Cycles: ~1200-1400 (16 iterations of shift-subtract)
/// Returns: a / b (quotient), or 0xFFFF if b == 0
/// Note: Uses zero page $20-$27 for temporary storage
///
/// Memory map (parameters):
/// $80-$81: parameter a (dividend)
/// $82-$83: parameter b (divisor)
///
/// Memory map (working):
/// $20-$21: dividend/remainder (modified during division)
/// $22-$23: divisor
/// $24-$25: quotient (result)
/// $26: loop counter (16 iterations)
/// $27: temp for division by zero check
pub fn div16(a: u16, b: u16) -> u16 {
    asm {
        // Check for division by zero (b == 0)
        "LDA $82",      // b.low
        "ORA $83",      // OR with b.high
        "BNE div16_not_zero",
        // Return 0xFFFF for division by zero
        "LDA #$FF",
        "TAY",
        "JMP div16_done",

        "div16_not_zero:",
        // Initialize quotient to 0
        "LDA #$00",
        "STA $24",
        "STA $25",

        // Load dividend from parameter a ($80-$81) into $20-$21
        "LDA $80",      // a.low
        "STA $20",
        "LDA $81",      // a.high
        "STA $21",

        // Load divisor from parameter b ($82-$83) into $22-$23
        "LDA $82",      // b.low
        "STA $22",
        "LDA $83",      // b.high
        "STA $23",

        // Initialize loop counter to 16
        "LDX #$10",
        "STX $26",

        "div16_loop:",
        // Shift quotient left by 1 (make room for new bit)
        "ASL $24",
        "ROL $25",

        // Shift remainder left by 1
        "ASL $20",
        "ROL $21",

        // Compare remainder with divisor
        // First compare high bytes
        "LDA $21",
        "CMP $23",
        "BCC div16_skip_sub",  // remainder.high < divisor.high, skip
        "BNE div16_do_sub",    // remainder.high > divisor.high, do subtract

        // High bytes equal, compare low bytes
        "LDA $20",
        "CMP $22",
        "BCC div16_skip_sub",  // remainder.low < divisor.low, skip

        "div16_do_sub:",
        // Subtract divisor from remainder
        "SEC",
        "LDA $20",
        "SBC $22",
        "STA $20",
        "LDA $21",
        "SBC $23",
        "STA $21",

        // Set bit 0 of quotient
        "INC $24",

        "div16_skip_sub:",
        // Decrement counter and loop if not zero
        "DEC $26",
        "BNE div16_loop",

        // Load quotient into A (low) and Y (high) per u16 return convention
        "LDA $24",
        "LDY $25",

        "div16_done:",
    }
}
